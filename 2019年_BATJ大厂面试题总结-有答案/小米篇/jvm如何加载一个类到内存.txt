jvm如何加载一个类到内存
	1.加载
		1)通过一个类的全限定名来获取定义此类的二进制字节流。
		2)将这个字节流所代表的静态存储结构转化为方法区域的运行时数据结构。
		3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区域数据的访问入口
	2.验证
		1)文件格式验证：验证字节流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理。
		2)元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范。
		3)字节码验证：主要是进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害虚拟机。
		4)符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。
	3.准备
		准备阶段为变量分配内存并设置类变量的初始化。在这个阶段分配的仅为类的变量（static修饰的变量），而不包括类的实例变量。对已非final的变量，JVM会将其设置成“零值”，而不是其赋值语句的值：
		pirvate static int size = 12;
		那么在这个阶段，size的值为0，而不是12。 final修饰的类变量将会赋值成真实的值。
	4.解析
		解析阶段是虚拟机常量池内的符号引用替换为直接引用的过程。
		符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。
		直接引用：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。
		虚拟机规范并没有规定解析阶段发生的具体时间，只要求了在执行anewarry、checkcast、getfield、instanceof、invokeinterface、invokespecial、invokestatic、invokevirtual、multianewarray、new、putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对它们使用的符号引用进行解析，所以虚拟机实现会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。
		解析的动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。分别对应编译后常量池内的CONSTANT_Class_Info、CONSTANT_Fieldref_Info、CONSTANT_Methodef_Info、CONSTANT_InterfaceMethoder_Info四种常量类型。
		1)类、接口的解析
		2)字段解析
		3)类方法解析
		4)接口方法解析
	5.初始化
		类的初始化阶段是类加载过程的最后一步，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器
	6.使用
		新线程---程序计数器----jvm栈执行（对象引用）-----堆内存（直接引用）----方法区
	7.卸载
		GC垃圾回收